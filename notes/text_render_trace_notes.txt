note:  below trace has errors, need to fix

SUBROUTINE 0x060BABF8 -- Switch/case for Text Escape sequence handling
==========================================================================
Throw stuff on stack
R12 now holds 264E32 (text script address)
R0 Holds the value at the text script address, FF01
R3 Holds value at 0x060BACE0, FF00
r3 and r0 are anded and the result is stored in r0  [in this instance r0 equaled FF00]
R10 = 0 and Branch Absolute to 0x60BAEE8
Move value at 0x060BAF50 into r1; r1 = F000
Compare r1/r0
If r1==r0, branch to 0x60BAE6E  (Code for 0xF000)
r1 = F080


060BAF50 to 0x60BAF7C -- Contain Hard-coded Escape sequences used for the switch clauses

Ctrl
Code       Branch Target Address
===============================
0000F000   0x60BAE6E - 
0000F080   0x60BAE6E - 
0000F100   0x60BAE6E - 
0000F400   0x60BAE6E - 
0000F500   0x60BAE6E -  
0000F600   0x60BAE6E - 
0000F800   0x60BAE14 - 
0000F900   0x60BADAA - Space, 2nd byte is # pixels
0000FA00   0x60BAE3A - Character Portrait
0000FB00   0x60BAE54 - 
0000FC00   0x60BADC4 - 
0000FF00   0x60BAC20 - Second byte of FF is: 01-next box, 02 newline, 03 start new box, FF end of dialog
RTS if no match with the above codes


0x60BAC20 (FF00 Decode)
=======================
mov.w@r12, r0
bra 0x60BAD86
extu.w r0,r0
r0 holds FF01

At 0x60BAD86 another switch case with jumps.  This time r1 = FF00, FF01, 
r1 is populated using 0x60BADFC, 60BAE00,  60BAE04,  60BAE08.  These correspond with FF00, FF01, FF02, FF03




Sequence for 2nd text of guy next to bridge/mill in upper right of Burg
This sequence is located starting at 264E32 (r14 initial value + 2): FF01 01D8 00D5 0174 F90A 019B 017A 024E 0195 FF02 000F 0010 0011 000D 0021 0018 001B 0012 00D5 0132 FF02 ... FFFF

Note that this happens to be located inside TEXT002.DAT



0x060BAA60 -- Start of Main Text Routine (Really!)
===========================================================
R14 holds 00264E34   <-- Current script address, Initially set by caller routine.  Updated by this routine.

060BAA60 add #0x02, r14  <-- Incr r14 by 2 bytes
060BAA62 mov.w @r14, r2  <-- r2 holds word at r14 (01D8)
060BAA64 extu.w r2, r2   <-- extend
060BAA66 cmp/eq r11,r2   <-- Does r2 == 0xFFFF (end of text identifier)
060BAA68 bf 0x060BAA3C   <-- Branch if false to 0x060BAA3C (Branch if we arent at the end)
                             

060BAA3C - Text draw routine: determine text or control characters
==================================================================
060BAA3C mov.w @r14, r2  <-- r2 holds word at r14 (01D8)
060BAA3E extu.w r2, r2   <-- extend
060BAA40 cmp/ge r13,r2   <-- Is r2 >= 0x0800 (seems to be a control character check)
060BAA42 bt 0x060BAA54   <-- If true go here
060BAA44 mov #0x01, r5   <-- r5 = 1
060BAA46 jsr @r10        <-- Jump to SUBROUTINE 06082D84
060BAA48 mov.w @r14, r4  <-- r4 = *r14     r4 becomes 01D8

060BAA54 mov.w @r14, r2  <-- r2 = FF01
060BAA56 extu.w r2, r2   <-- extend
060BAA58 cmp/ge r12, r2  <-- r12 is 0xF000
060BAA5A bf 0x060BAA60   <-- go back to the start of the routine (skips this 2-byte character)
060BAA5C bsr 0x060BABF8


SUBROUTINE 06082D84  (Copy text character to VDP2?)
====================================================
push stuff onto the stack
r0 is now r5, so r0 = 1
r10 = 0
r9  = 8
06082D9A add #0xD8, r15           <-- r15 = 06001F1C
06082D9C mov.l @(0x09C, pc), r11  <-- r11 = 060f8574
06082D9E mov r15, r12             <-- r12 = 06001F1C
06082DA0 mov.1 @(0x09C, pc), r14  <-- r14 = 060f8578
06082DA2 add #0x18, r12           <-- r12 = 06001F34
06082DA4 mov.w r4, @r15           <-- *0x06001F1C = 01D8
06082DA6 mov.l r5, @(0x00C, r15)  <-- *0x06001F28 = 0000_0001
06082DA8 tst r0, r0               <-- r0 = 1, T bit is set to 0
06082DAA bf/s 06082DC4            <-- delayed branch always taken since T bit is 0
06082DAC mov #0x01, r13           <-- r13 = 1

06082DC4 mov.w @r15, r2           <--  r2 = 01D8 (in this instance, hasnt changed from before)
06082DC6 extu.w r2, r2            <--  The next 3 three lines multiply the value by 8
06082DC8 shll2 r2                 <--  r2 = 0760   
06082DCA shll2 r2                 <--  r2 = 1D80
06082DCC shll2 r2                 <--  r2 = 7600
06082DCE mov.l @(0x074,pc), r3    <--  r3 = 060F856C
06082DD0 mov.l @r3, r3            <--  r3 = 00220000  <-- Start of 16x16 Font in V
06082DD2 add r3, r2               <--  r2 = 00227600  <-- Location of character to copy
06082DD4 mov.w r2, @(0x004, r15)  <--  *0x06001F20 = 00227600
06082DD6 mov r10, r5              <--  r5 = 0
06082DD8 mov r2, r4               <--  r4 = 00227600
06082DDA mov r2, r6               <--  r6 = 00227600
06082DDC add #0x40, r6            <--  r6 = 00227640   <-- add 64 to the start location?

06082DDE mov.l @r4, r3            <--  r3 = *00227600 ; r3 = 00000000
06082DE0 add #0x04, r4            <--  r4 = 00227604
06082DE2 or r3, r5                <--  r5 = 00000000
06082DE4 mov.l @r4, r2            <--  r2 = 00000000
06082DE6 add #0x04, r4            <--  r4 = 00227608
06082DE8 cmp/hs r6,r4             <--  T=1 if r4 >= r6.  T = 0 in this case.
06082DEA bf/s 0x06082DDE          <--  Delayed Branch, Causes a loop
06082DEC or r2, r5                <--  r5 = 00000000

DDE to DEC loop:
Or's together 16 32-bit words
L1
r3 = *00227600 ; r3 = 00000000
r4 = 00227604
r5 = 00000000
r2 = 00000000
r4 = 00227608

L2
r3 = *00227608 ; r3 = 00300000
r4 = 0022760C
r5 = 00300000
r2 = 00DFF3C0
r4 = 00227610
r5 = 00FFF3C0 (from or of r2 and r5)
...

End:  R5 = FFFFFFFC




06082DEE mov r10, r8              <-- r8 = 0
06082DF0 mov r8, r1               <-- r1 = 0
06082DF2 mov.l @(0x054, pc), r3   <-- r3 = 060D8840
06082DF4 shll r1                  <-- r1 = 0
06082DF6 jsr @r3                  <-- Jump to 060D8840
06082DF8 mov r5, r0               <--
06082DFA tst #0x03, r0            <-- (r0 is FFFFFFFC)  T = 1
06082DFC bt  0x06082E02           <--
06082DFE bra 0x06082E0A           <--
06082E00 nop                      <--
06082E02 <--left off here



SUBROUTINE 060D8840
========================
060D8840 mov.l r2, @-r15   <-- handle stack
060D8842 cmp/pz r1         <-- T=1 if r1 >= 0
060D8844 bf/s 0x060D8878
060D8846 mov #0x20, r2     <-- r2 = 0x20
060D8848 cmp/ge r2, r1     <-- r1 is not ge r2, T = 0
060D884A bt 0x060D8864
060D884C mov.l @(0x14, pc), r2  <-- r2 = 0x060D8820
060D884E add r1, r2             <-- r2 = 0x060D8820
060D8850 mov.b @r2, r2          <-- r2 is the data at the address, 0xE
060D8852 mov.l @(0xC, pc), r1   <-- r1 = 060D886A
060D8854 add r2, r1             <-- r1 = 060D8878
060D8856 jmp @r1                <-- Jump to r1
060D8858 nop
060D885A nop
060D885C mov.w @(r0,r0), r6
060D885E cmp/eq #0x6A, r0
060D8860 mov.w @(r0,r0), r6
060D8862 cmp/eq #0x20, r0
060D8864 mov #00, r0
060D8866 rts
060D8868 mov.l @r15+, r2   <-- handle stack

060D8878 rts



























SCRIPT READER ROUTINE
===================================

060BA1F2 r3 = 0x60BE5E4
060BA1F4 jsr @r3
060BA1F6 nop

jsr 06080C68
jsr 0x60DEDC4
jsr 0x60D81A8
jsr 0x60D81A8

0608184C <-- r0 now



060BA07C ??
060C5BC4
060BA616 ??

060BA1FC shll r4  <-- r4 = 60<<2 =  C0
r3 = 260000
r4 = r3+r4 = 2600C0
r4 = *r4 = FD8
060BA226 shll r4           <-- r4 = 1FB0


060BA22A mov.l @r2, r2     <-- r2 = 260000 , which is the start of the script
060BA22C add r2, r4        <-- r4 = 261FB0 (26000 + 1FB0)
060BA22E bra 0x060BA2AC    <-- Delayed Branch
060BA230 mov.l r4, @r13    <-- *0x60F956C = 261FB0

060BA2AC mov.l @r11, r0    <-- r0 = 0
060BA2AE tst r0, r0        <-- T = 1  Take the following branch
060BA2B0 bt 0x060BA298
060BA2B2 mov.l @(0x0A0,pc), r3
060BA2B4 jsr @r3
060BA2B6 nop


060BA298 mov.l @r13, r2         <-- r2 = 261FB0
060BA29A mov.w @r2, r3          <-- r3 = 3
060BA29C mov.w r3, @r12         <-- *0x060F95A4 = 3
060BA29E mov.l @r13, r0         <-- r0 = *0x060F956C = 261FB0
060BA2A0 mov.w @r0, r0          <-- r0 = 3
060BA2A2 extu.w r0, r0          <-- 
060BA2A4 shll2 r0               <-- r0 = 3*4 = C
060BA2A6 mov.l @(r0, r8), r3    <-- r3 = *0x060F1D18 = 0x60BB830
060BA2A8 jsr @r3                <-- jump
060BA2AA nop                     

0x60BB830 


261FB0=0003  r0 = C   (shift left 2)
261FB2=012C  r0 = 258 (shift left 2)
r5 = *0x260258 = 266A (shift left 2) = 4CD4
r5 = 264CD4
060BA2B8 
0x060BA2A8 jsr @r3   <-- calls text draw routine with r14 set to beginning of script
